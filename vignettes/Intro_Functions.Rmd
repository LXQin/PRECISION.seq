---
title: "Introduction to DepthNorm Functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intro_Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, warning = FALSE, message = FALSE}
rm(list = ls())
library(precision.seq)
library(DESeq)
```

One critical aspect of RNA sequencing data normalization is the sequencing depth. We prepared nine commonly used depth normalization methods and a pair of well-designed datasets used for statistical evaluations in this package.

## Functions for Depth Normalization
In this section, we will present how to use the normalization functions in this package. The raw count data in the format of data frame or matrix (with columns for samples and rows for markers/genes) and the vector of characters indicating the group of each sample are needed as input. The output depends on the normalization methods. If the normalization methods are re-scalling based, normalized dataset and scalling factor will be provided as output; if the normalization methods are regression based, normalized dataset, which only used for exploration and the adjusting factor will be provided as output.
```{r warning = FALSE, message = FALSE}
test.TC <- norm.TC(data.test, data.group)
test.UQ <- norm.UQ(data.test, data.group)
test.med <- norm.med(data.test, data.group)
test.TMM <- norm.TMM(data.test, data.group)
test.DESeq <- norm.DESeq(data.test, data.group)
test.PoissonSeq <- norm.PoissonSeq(data.test)
test.QN <- norm.QN(data.test)
test.SVA <- norm.SVA(data.test, data.group)
test.RUVg <- norm.RUV(data.test, data.group, method = "RUVg")
test.RUVs <- norm.RUV(data.test, data.group, method = "RUVs")
test.RUVr <- norm.RUV(data.test, data.group, method = "RUVr")

head(test.TMM$scaling.factor)
head(test.TMM$dat.normed[,1:5])

head(test.SVA$adjust.factor)
head(test.SVA$dat.normed[,1:5])
```

## Functions for Differential Expression Analysis
We pack two DEA functions, edgeR and voom-limma, in this package. The input could be either the normalized dataset (always from re-scalling methods) or the non-normalized dataset with adjusting factor (always from regression-based methods). Names of DE markers/genes (p = 0.01 as cut-off point by default), p-values for each marker/gene, and log2 fold change are provided in output.
```{r}
edgeR.benchmark <- DE.edgeR(data.benchmark, data.group)
voom.benchmark <- DE.voom(data.benchmark, data.group)

edgeR.test.TMM <- DE.edgeR(test.TMM$dat.normed, data.group)
voom.test.TMM <- DE.voom(test.TMM$dat.normed, data.group)

edgeR.test.RUVr <- DE.edgeR(data.test, data.group, 
                            normalized = FALSE,
                            adjust = test.RUVr$adjust.factor)
voom.test.RUVr <- DE.voom(data.test, data.group, 
                          normalized = FALSE,
                          adjust = test.RUVr$adjust.factor)

head(voom.benchmark$id.list)
head(voom.benchmark$p.val)

head(voom.test.RUVr$id.list)
head(voom.test.RUVr$p.val)
```


## Functions for Combininig Normalization and Differential Expression Analysis
We combine normalization and DEA functions together, so that users could start from raw read counts and directly obtain the DE genes and the corresponding p-values (as same as the output of DE functions). In addition, we prepare a function for computing the true positive rate, false positive rate, false discovery rate, and false negative rate based on given golden standards.  
```{r}
res <- pip.norm.DE(data.test, data.group, "norm.TMM")

truthgene <- DE.voom(data.benchmark, data.group)$id.list
stat <- pip.statistics(data.test, data.group, "norm.TMM", truth = truthgene)
stat
```
